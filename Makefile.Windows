#
# GNU Makefile for Hamlib (MSVC / clang-cl / MinGW).
#
# G. Vanem <gvanem@yahoo.no> 2019 - 2021.
#
THIS_FILE = Makefile.Windows
DATE      = $(shell date +%d-%B-%Y)
ABI_VER   = 4

#
# From 'configure.ac':
#
MAJOR_VER = 4
MINOR_VER = 2
VERSION   = $(MAJOR_VER).$(MINOR_VER)

#
# Choose your weapons. Do a 'make vclean' after changing any of these.
#
USE_LIBGD       ?= 1
USE_LIBINDI     ?= 0
USE_LIBREADLINE ?= 0
USE_LIBUSB      ?= 1
USE_LIBUSRP     ?= 1
USE_LIBXML2     ?= 1
USE_LUAJIT      ?= 0
USE_MP_COMPILE  ?= 1

#
# Add support for a 'GnuRadio' device.
# Impossible as it is not up-to-date with current GnuRadio 3.9 API.
#
USE_GNURADIO ?= 0

#
# Use the Winsock tracing library (works badly for MinGW):
#   https://github.com/gvanem/wsock-trace
#
USE_WSOCK_TRACE ?= 1

#
# Use only static external libraries to create '$(Hamlib_DLL)'.
# But '_Hamlib.pyd' and 'HamlibLua.dll' always uses '$(Hamlib_DLL)'.
#
USE_STATIC ?= 1

#
# Use '$(Hamlib_DLL)' for all C programs.
# And '$(Hamlib++_DLL)' for all C++ programs.
#
USE_DLLs_FOR_PROGRAMS ?= 1

#
# Set to 0 for no Python module.
# Set to 2 to create a Python 2.x module.
# Set to 3 to create a Python 3.x module.
#
USE_PY_BINDING ?= 3

#
# Use 'astyle' or 'clang-format' in the "%.i: %.c" preprocess rules below.
#
USE_ASTYLE       ?= 0
USE_CLANG_FORMAT ?= 0

#
# Change these as needed:
# (or create env-vars like 'LIBXML2_ROOT=c:/whatever/xml2').
#
LIBXML2_ROOT     ?= f:/MinGW32/src/Parsers/libxml2
LIBICONV_ROOT    ?= f:/MinGW32/src/libiconv-1.15
LIBGD_ROOT       ?= f:/MinGW32/src/Graphics/libgd-2.1.0
LIBREADLINE_ROOT ?= f:/MinGW32/src/misc/libreadline
LUAJIT_ROOT      ?= f:/MinGW32/src/LUA/LuaJIT
LUA5_ROOT        ?= f:/MinGW32/src/LUA/Lua-5.4
LIBUSB_ROOT      ?= f:/MinGW32/src/USB/libusb
LIBUSRP_ROOT     ?= f:/gv/dx-radio/Bor-IP/src/libusrp/usrp/host
GNURADIO_ROOT    ?= f:/gv/dx-radio/GnuRadio/gv-build
LIBINDI_ROOT     ?= f:/ProgramFiler/Stellarium/src/src/external/libindi

PYTHON ?= py -3

ifeq ($(USE_LUAJIT),1)
  LUA_ROOT = $(realpath $(LUAJIT_ROOT))
  LUA_LIB  = $(call select, $(LUA_ROOT)/src/libluajit.a, $(LUA_ROOT)/src/luajit.lib)
else
  LUA_ROOT = $(realpath $(LUA5_ROOT))
  LUA_LIB  = $(call select, $(LUA_ROOT)/src/liblua.a, $(LUA_ROOT)/src/lua.lib)
endif

MKDIR = mkdir
RMDIR = rmdir --parents
MOVE  = mv --force
COPY  = cp --preserve=timestamps --update

#
# 'clang-cl' may not like stuff in '%CL'.
# Just remove it.
#
export CL=

define Usage

  Usage: "$(MAKE) -f $(THIS_FILE) CC=[cl | clang-cl | gcc] [CPU=x86 | x64] [all | clean | vclean | realclean | depend | doxy_docs | py_module | lua_module]"
  Specify CC=cl       - use MSVC
  Specify CC=clang-cl - use clang-cl
  Specify CC=gcc      - use MinGW
endef

#
# Check the casing of '$CPU'. GNU-make is case-sensitive.
#
ifeq ($(CPU),)
  CPU = x86
endif

ifeq ($(CPU),X86)
  CPU = x86
else ifeq ($(CPU),X64)
  CPU = x64
endif

#
# If '$(CPU)=x64', build 64-bit version. Assuming your MinGW
# is dual-target capable and supports the '-mxx' option.
# Otherwise 32-bit programs.
#
ifeq ($(CPU),x64)
  BITS     = 64
  RCFLAGS  = --target=pe-x86-64
  X_SUFFIX = _x64
else
  BITS     = 32
  RCFLAGS  = --target=pe-i386
  X_SUFFIX =
endif

ifeq ($(CC),gcc)
  OBJ_DIR = MinGW_obj
  USE_MP_COMPILE := 0

else ifeq ($(CC),clang-cl)
  OBJ_DIR = clang_obj
  USE_MP_COMPILE := 0

else ifeq ($(CC),cl)
  OBJ_DIR = MSVC_obj

else
  $(error $(Usage))
endif

ifeq ($(CC),gcc)
  select  = $(1)
  CFLAGS  = -m$(BITS) -O2 -g --include config.h
  LDFLAGS = -m$(BITS) -Wl,--print-map,--sort-common
  O       = o
  A       = a

  #
  # We want true Winsock2. Not some POSIX emulation that messes up things big-time.
  #
  CFLAGS += -D__USE_W32_SOCKETS

  WS2_32_LIB = -lws2_32

else
  select  = $(2)
  CFLAGS  = -nologo -MD -W3 -Zi -O2 -EHsc -DWIN32 -FI./config.h
  LDFLAGS = -nologo -debug -incremental:no -verbose -machine:$(CPU) -nodefaultlib:uuid.lib
  O       = obj
  A       = lib

  ifeq ($(CC),clang-cl)
    CFLAGS += -fms-compatibility -ferror-limit=5
  endif

  ifeq ($(USE_WSOCK_TRACE),1)
    WS2_32_LIB = wsock_trace.lib
  else
    WS2_32_LIB = ws2_32.lib
  endif
endif

#
# Warning control:
#
ifeq ($(CC),gcc)
  CFLAGS += -Wall                \
            -Wno-format          \
            -Wno-array-bounds    \
            -Wno-missing-braces  \
            -Wno-unused-function \
            -Wno-unused-variable \
            -Wno-shift-count-overflow

else ifeq ($(CC),clang-cl)
  CFLAGS += -Wall                                   \
            -Wno-undef                              \
            -Wno-unused-function                    \
            -Wno-unused-macros                      \
            -Wno-unused-parameter                   \
            -Wno-unused-variable                    \
            -Wno-visibility                         \
            -Wno-unknown-pragmas                    \
            -Wno-ignored-attributes                 \
            -Wno-strict-prototypes                  \
            -Wno-reserved-id-macro                  \
            -Wno-shadow                             \
            -Wno-cast-align                         \
            -Wno-cast-qual                          \
            -Wno-shorten-64-to-32                   \
            -Wno-pedantic                           \
            -Wno-format-pedantic                    \
            -Wno-format-nonliteral                  \
            -Wno-switch-enum                        \
            -Wno-covered-switch-default             \
            -Wno-sign-conversion                    \
            -Wno-sign-compare                       \
            -Wno-double-promotion                   \
            -Wno-assign-enum                        \
            -Wno-unreachable-code                   \
            -Wno-unreachable-code-return            \
            -Wno-unreachable-code-break             \
            -Wno-c++98-compat-pedantic              \
            -Wno-old-style-cast                     \
            -Wno-extra-semi-stmt                    \
            -Wno-missing-field-initializers         \
            -Wno-missing-noreturn                   \
            -Wno-missing-prototypes                 \
            -Wno-missing-variable-declarations      \
            -Wno-bad-function-cast                  \
            -Wno-redundant-parens                   \
            -Wno-tautological-unsigned-zero-compare \
            -Wno-nonportable-system-include-path    \
            -Wno-implicit-int-conversion            \
            -Wno-float-conversion                   \
            -Wno-float-equal                        \
            -Wno-implicit-float-conversion          \
            -Wno-implicit-fallthrough               \
            -Wno-shift-count-overflow               \
            -Wno-documentation                      \
            -Wno-documentation-unknown-command      \
            -Wno-gnu-zero-variadic-macro-arguments  \
            -Wno-zero-as-null-pointer-constant

  ifeq ($(USE_LIBUSRP),1)
    CFLAGS += -Wno-suggest-override \
              -Wno-suggest-destructor-override
  endif

  #
  # When on AppVeyor, do not suppress these warnings since they have an old 'clang-cl'.
  #
  ifeq ($(APPVEYOR_PROJECT_NAME)x,x)
    CFLAGS += -Wno-implicit-int-float-conversion \
              -Wno-deprecated-copy-dtor
  endif

  #
  # This warning is kinda important:
  #
  #   rigs/dummy/dummy.h(46,5):  warning: 'netrigctl_get_vfo_mode' redeclared without 'dllimport' attribute: previous
  #   'dllimport' ignored [-Winconsistent-dllimport]
  #    int netrigctl_get_vfo_mode(RIG *);
  #        ^
  # So do not add a '-Wno-inconsistent-dllimport'.
  #
  # And so is this '-Wconditional-uninitialized'.
  #
else
  CFLAGS += -wd4018 -wd4101 -wd4142 -wd4146 -wd4244 -wd4251 -wd4305 -wd4700 -wd4800

  ifeq ($(BITS),64)
    CFLAGS += -wd4267
  endif
endif

# CFLAGS += -DHASH_BLOOM

#
# External libraries for '$(Hamlib_DLL)':
#
EX_LIBS = $(WS2_32_LIB)

#
# The DLL and library names:
#
Hamlib_DLL      = Hamlib-$(ABI_VER).dll
Hamlib_IMP_LIB  = $(call select, libHamlib-$(ABI_VER).dll.a, Hamlib-$(ABI_VER)_imp.lib)
Hamlib_STAT_LIB = $(call select, libHamlib-$(ABI_VER).a,     Hamlib-$(ABI_VER).lib)

#
# The C++ library
#
Hamlib++_DLL     = Hamlib-$(ABI_VER)++.dll
Hamlib++_IMP_LIB = $(call select, libHamlib-$(ABI_VER)++.dll.a, Hamlib-$(ABI_VER)++_imp.lib)

#
# The internal utility library; '$(hamlib_misc_SRC)'.
#
misc_LIB = $(call select, libmisc.a, misc.lib)

#
# What to build:
#
TARGETS = $(Hamlib_STAT_LIB) $(Hamlib_DLL) \
          $(Hamlib_IMP_LIB)  $(misc_LIB)

#
# The C++ interface is dynamic only.
#
TARGETS += $(Hamlib++_DLL) $(Hamlib++_IMP_LIB)

#
# For 'test/*.c' only. They all use '$(Hamlib_DLL)'.
#
PROG_LIBS = $(WS2_32_LIB) $(call select, -lwinpthread)

ifeq ($(USE_DLLs_FOR_PROGRAMS),1)
  #
  # A strangely named macro ('-DUSE_Hamlib_DLL' would be better), but
  # this will let all .c and .cc programs to use 'Hamlib-$(ABI_VER).dll'
  #
  PROG_CFLAGS = -DDLL_EXPORT

  #
  # Use 'Hamlib-$(ABI_VER).dll' for C programs.
  #
  C_PROG_LIBS = $(misc_LIB) $(Hamlib_IMP_LIB)

  #
  # Use 'Hamlib-$(ABI_VER)++.dll and 'Hamlib-$(ABI_VER).dll' for C++ programs.
  # The library order matter for MinGW only.
  #
  CPP_PROG_LIBS = $(Hamlib_IMP_LIB) $(Hamlib++_IMP_LIB)
else
  PROG_CFLAGS   =
  PROG_LIBS     = $(EX_LIBS)
  C_PROG_LIBS   = $(Hamlib_STAT_LIB) $(misc_LIB)
  CPP_PROG_LIBS = $(Hamlib_STAT_LIB) $(misc_LIB) $(Hamlib++_IMP_LIB)
endif

#
# For 'rigs/kit/usrp.c' and 'rigs/kit/usrp_impl.cc'.
# This needs Boost too. Untested by me.
#
ifeq ($(USE_LIBUSRP),1)
  CFLAGS += -DHAVE_USRP               \
            -I$(LIBUSRP_ROOT)/include \
            -I$(LIBUSRP_ROOT)/include/usrp

  EX_LIBS += $(call select, $(LIBUSRP_ROOT)/libUSRP.a, \
                            $(LIBUSRP_ROOT)/libUSRP_imp.lib)

  hamlib_CC_SRC = kit/usrp_impl.cc
endif

ifeq ($(USE_LIBUSB),1)
  CFLAGS += -DHAVE_LIBUSB   \
            -DHAVE_LIBUSB_H \
            -I$(LIBUSB_ROOT)/libusb

  ifeq ($(USE_STATIC),1)
    EX_LIBS += $(call select, $(LIBUSB_ROOT)/libusb-1.0.a -ladvapi32, \
                              $(LIBUSB_ROOT)/libusb-1.0.lib advapi32.lib)
  else
    EX_LIBS += $(call select, $(LIBUSB_ROOT)/libusb-1.0.dll.a, \
                              $(LIBUSB_ROOT)/libusb-1.0_imp.lib)
  endif
endif

#
# Untested; does it exist except for MinGW?
#
ifeq ($(USE_LIBREADLINE),1)
  CFLAGS += -DHAVE_LIBREADLINE \
            -I$(LIBREADLINE_ROOT)/include

  EX_LIBS += $(call select, $(LIBREADLINE_ROOT)/libreadline.a, \
                            $(LIBREADLINE_ROOT)/libreadline.lib)
endif

CFLAGS += -I.                \
          -I./include        \
          -I./include/hamlib \
          -I./lib            \
          -I./src            \
          -I./tests

ifneq ($(CC),gcc)
  CFLAGS  += -I$(OBJ_DIR)
  EX_LIBS += user32.lib kernel32.lib
endif

c_to_obj = $(addprefix $(OBJ_DIR)/, \
             $(notdir $(1:.c=.$(O))))

cc_to_obj = $(addprefix $(OBJ_DIR)/, \
              $(notdir $(1:.cc=.$(O))))

cpp_to_obj = $(addprefix $(OBJ_DIR)/, \
               $(notdir $(1:.cpp=.$(O))))

c_to_i  = $(notdir $(1:.c=.i))
cc_to_i = $(notdir $(1:.cc=.i))

VPATH = rigs/dummy src tests c++ amplifiers/elecraft

VPATH += $(addprefix rigs/, \
           adat             \
           alinco           \
           aor              \
           barrett          \
           dorji            \
           drake            \
           elad             \
           flexradio        \
           icmarine         \
           icom             \
           jrc              \
           kachina          \
           kenwood          \
           kit              \
           lowe             \
           pcr              \
           prm80            \
           racal            \
           rft              \
           rs               \
           skanti           \
           tapr             \
           tentec           \
           tuner            \
           uniden           \
           winradio         \
           wj               \
           yaesu)

VPATH += $(addprefix rotators/, \
           amsat                \
           ars                  \
           celestron            \
           cnctrk               \
           easycomm             \
           ether6               \
           fodtrack             \
           gs232a               \
           heathkit             \
           indi                 \
           ioptron              \
           m2                   \
           meade                \
           prosistel            \
           rotorez              \
           sartek               \
           satel                \
           spid                 \
           ts7400)

#
# For compiling 'HamlibPy2_wrap.c,' 'HamlibPy3_wrap.c' and 'HamlibLua_wrap.c'.
#
VPATH += $(OBJ_DIR)

#
# All of these use '$(Hamlib_DLL)':
#
TESTS_PROGS = ampctl.exe      \
              ampctld.exe     \
              dumpmem.exe     \
              example.exe     \
              listrigs.exe    \
              rigctl.exe      \
              rigctld.exe     \
              rigctlcom.exe   \
              rigsmtr.exe     \
              rigswr.exe      \
              rig_bench.exe   \
              rotctl.exe      \
              rotctld.exe     \
              simyaesu.exe    \
              testbcd.exe     \
              testfreq.exe    \
              testloc.exe     \
              testrig.exe     \
              testrigcaps.exe \
              testrigopen.exe \
              testtrn.exe

ifneq ($(APPVEYOR_PROJECT_NAME),)
  #
  # TODO: build with 'LIBUSB_ROOT = ./CI/libusb', 'LIBXML2_ROOT = ./CI/libxml2' etc.
  #       when running via 'appveyor.yml'
  #
endif

ifeq ($(USE_LIBXML2),1)
  TESTS_PROGS += rigmem.exe
  PROG_CFLAGS += -I$(LIBXML2_ROOT)/include  \
                 -I$(LIBICONV_ROOT)/include \
                 -DHAVE_XML2

  #
  # Use the dynamic version of 'libxml2'.
  # I.e. do not set 'PROG_CFLAGS += -DLIBXML_STATIC'.
  # Otherwise we could need to link to a static 'Iconv', 'Zlib' and
  # a 'liblzma' too (depending on how 'libxml2' was built).
  #
  XML2_LIB = $(call select, $(LIBXML2_ROOT)/libxml2.dll.a, \
                            $(LIBXML2_ROOT)/xml2_imp.lib)
endif

ifeq ($(USE_LIBGD),1)
  TESTS_PROGS += rigmatrix.exe
  PROG_CFLAGS += -I$(LIBGD_ROOT)/src
endif

#
# This always uses '$(Hamlib++_DLL)'.
#
TESTS_PROGS += testcpp.exe

#
# All .c-files for '$(Hamlib_DLL)'.
# Except for those in '$(hamlib_misc_SRC)' which do not need to be exported.
#
hamlib_C_SRC = $(addprefix src/, \
                 amp_conf.c      \
                 amp_reg.c       \
                 amp_settings.c  \
                 amplifier.c     \
                 cal.c           \
                 cm108.c         \
                 conf.c          \
                 debug.c         \
                 event.c         \
                 ext.c           \
                 extamp.c        \
                 gpio.c          \
                 locator.c       \
                 iofunc.c        \
                 mem.c           \
                 misc.c          \
                 microham.c      \
                 network.c       \
                 parallel.c      \
                 register.c      \
                 rig.c           \
                 rot_conf.c      \
                 rot_ext.c       \
                 rot_reg.c       \
                 rot_settings.c  \
                 rotator.c       \
                 serial.c        \
                 settings.c      \
                 sleep.c         \
                 tones.c         \
                 usb_port.c)

hamlib_C_SRC += $(addprefix rigs/dummy/, \
                  amp_dummy.c            \
                  dummy.c                \
                  dummy_common.c         \
                  flrig.c                \
                  netampctl.c            \
                  netrigctl.c            \
                  netrotctl.c            \
                  rot_dummy.c            \
                  trxmanager.c)

hamlib_C_SRC += $(addprefix rigs/adat/, \
                  adat.c                \
                  adt_200a.c)

hamlib_C_SRC += $(addprefix rigs/alinco/, \
                  alinco.c                \
                  dx77.c                  \
                  dxsr8.c)

hamlib_C_SRC += $(addprefix rigs/aor/, \
                  aor.c                \
                  ar2700.c             \
                  ar3000.c             \
                  ar3030.c             \
                  ar5000.c             \
                  ar7030.c             \
                  ar7030p.c            \
                  ar7030p_utils.c      \
                  ar8000.c             \
                  ar8200.c             \
                  ar8600.c             \
                  sr2200.c)

hamlib_C_SRC += $(addprefix rigs/barrett/, \
                  950.c                    \
                  barrett.c)

hamlib_C_SRC += $(addprefix rigs/dorji/, \
                  dorji.c                \
                  dra818.c)

hamlib_C_SRC += $(addprefix rigs/drake/, \
                  drake.c                \
                  r8a.c                  \
                  r8b.c)

hamlib_C_SRC += $(addprefix rigs/elad/, \
                  elad.c                \
                  fdm_duo.c)

hamlib_C_SRC += $(addprefix rigs/flexradio/, \
                  dttsp.c                    \
                  flexradio.c                \
                  sdr1k.c)

hamlib_C_SRC += $(addprefix rigs/icmarine/, \
                  icm700pro.c               \
                  icm710.c                  \
                  icm802.c                  \
                  icm803.c                  \
                  icmarine.c)

hamlib_C_SRC += $(addprefix rigs/icom/, \
                  delta2.c              \
                  frame.c               \
                  ic78.c                \
                  ic92d.c               \
                  ic271.c               \
                  ic275.c               \
                  ic471.c               \
                  ic475.c               \
                  ic703.c               \
                  ic706.c               \
                  ic707.c               \
                  ic718.c               \
                  ic725.c               \
                  ic726.c               \
                  ic728.c               \
                  ic735.c               \
                  ic736.c               \
                  ic737.c               \
                  ic738.c               \
                  ic746.c               \
                  ic751.c               \
                  ic756.c               \
                  ic761.c               \
                  ic765.c               \
                  ic775.c               \
                  ic781.c               \
                  ic785x.c              \
                  ic820h.c              \
                  ic821h.c              \
                  ic910.c               \
                  ic970.c               \
                  ic1275.c              \
                  ic2730.c              \
                  ic7000.c              \
                  ic7100.c              \
                  ic7200.c              \
                  ic7300.c              \
                  ic7410.c              \
                  ic7600.c              \
                  ic7610.c              \
                  ic7700.c              \
                  ic7800.c              \
                  ic9100.c              \
                  icom.c                \
                  icr6.c                \
                  icr10.c               \
                  icr20.c               \
                  icr30.c               \
                  icr71.c               \
                  icr72.c               \
                  icr75.c               \
                  icr7000.c             \
                  icr8500.c             \
                  icr8600.c             \
                  icr9000.c             \
                  icr9500.c             \
                  icrx7.c               \
                  id1.c                 \
                  id31.c                \
                  id4100.c              \
                  id51.c                \
                  id5100.c              \
                  omni.c                \
                  optoscan.c            \
                  os456.c               \
                  os535.c               \
                  perseus.c             \
                  x108g.c)

hamlib_C_SRC += $(addprefix rigs/jrc/, \
                  jrc.c                \
                  nrd525.c             \
                  nrd535.c             \
                  nrd545.c)

hamlib_C_SRC += $(addprefix rigs/kachina/, \
                  505dsp.c                 \
                  kachina.c)

hamlib_C_SRC += $(addprefix rigs/kenwood/, \
                  elecraft.c               \
                  flex.c                   \
                  flex6xxx.c               \
                  ic10.c                   \
                  k2.c                     \
                  k3.c                     \
                  kenwood.c                \
                  pihpsdr.c                \
                  r5000.c                  \
                  th.c                     \
                  thd7.c                   \
                  thd72.c                  \
                  thd74.c                  \
                  thf6a.c                  \
                  thf7.c                   \
                  thg71.c                  \
                  tmd700.c                 \
                  tmd710.c                 \
                  tmv7.c                   \
                  transfox.c               \
                  trc80.c                  \
                  ts50s.c                  \
                  ts140.c                  \
                  ts440.c                  \
                  ts450s.c                 \
                  ts480.c                  \
                  ts570.c                  \
                  ts590.c                  \
                  ts680.c                  \
                  ts690.c                  \
                  ts711.c                  \
                  ts790.c                  \
                  ts811.c                  \
                  ts850.c                  \
                  ts870s.c                 \
                  ts930.c                  \
                  ts940.c                  \
                  ts950.c                  \
                  ts990s.c                 \
                  ts2000.c                 \
                  xg3.c)

hamlib_C_SRC += $(addprefix rigs/kit/, \
                  dds60.c              \
                  drt1.c               \
                  dwt.c                \
                  elektor304.c         \
                  elektor507.c         \
                  fifisdr.c            \
                  funcube.c            \
                  hiqsdr.c             \
                  kit.c                \
                  miniVNA.c            \
                  pcrotor.c            \
                  rs_hfiq.c            \
                  si570avrusb.c        \
                  usrp.c)

hamlib_C_SRC += $(addprefix rigs/lowe/, \
                  hf235.c               \
                  lowe.c)

hamlib_C_SRC += $(addprefix rigs/pcr/, \
                  pcr.c                \
                  pcr100.c             \
                  pcr1000.c            \
                  pcr1500.c            \
                  pcr2500.c)

hamlib_C_SRC += $(addprefix rigs/prm80/, \
                  prm80.c                \
                  prm8060.c)

hamlib_C_SRC += $(addprefix rigs/racal/, \
                  ra37xx.c               \
                  ra3702.c               \
                  ra6790.c               \
                  racal.c)

hamlib_C_SRC += $(addprefix rigs/rft/, \
                  ekd500.c             \
                  rft.c)

hamlib_C_SRC += $(addprefix rigs/rs/, \
                  eb200.c             \
                  esmc.c              \
                  gp2000.c            \
                  rs.c                \
                  xk2100.c)

hamlib_C_SRC += $(addprefix rigs/skanti/, \
                  skanti.c                \
                  trp8000.c               \
                  trp8255.c)

hamlib_C_SRC += $(addprefix rigs/tapr/, \
                  dsp10.c               \
                  tapr.c)

hamlib_C_SRC += $(addprefix rigs/tentec/, \
                  argonaut.c              \
                  jupiter.c               \
                  omnivii.c               \
                  orion.c                 \
                  paragon.c               \
                  pegasus.c               \
                  rx320.c                 \
                  rx331.c                 \
                  rx340.c                 \
                  rx350.c                 \
                  tentec.c                \
                  tentec2.c               \
                  tt550.c)

hamlib_C_SRC += $(addprefix rigs/tuner/, \
                  tuner.c                \
                  v4l.c                  \
                  v4l2.c)

hamlib_C_SRC += $(addprefix rigs/uniden/, \
                  bc245.c                 \
                  bc250.c                 \
                  bc780.c                 \
                  bc895.c                 \
                  bc898.c                 \
                  bcd396t.c               \
                  bcd996t.c               \
                  pro2052.c               \
                  uniden.c                \
                  uniden_digital.c)

hamlib_C_SRC += $(addprefix rigs/winradio/, \
                  g303.c                    \
                  g305.c                    \
                  g313-win.c                \
                  winradio.c                \
                  wr1000.c                  \
                  wr1500.c                  \
                  wr1550.c                  \
                  wr3100.c                  \
                  wr3150.c                  \
                  wr3500.c                  \
                  wr3700.c)

hamlib_C_SRC += $(addprefix rigs/wj/, \
                  wj.c                \
                  wj8888.c)

hamlib_C_SRC += $(addprefix rigs/yaesu/, \
                  frg100.c               \
                  frg8800.c              \
                  frg9600.c              \
                  ft100.c                \
                  ft450.c                \
                  ft600.c                \
                  ft736.c                \
                  ft747.c                \
                  ft757gx.c              \
                  ft767gx.c              \
                  ft817.c                \
                  ft840.c                \
                  ft847.c                \
                  ft857.c                \
                  ft890.c                \
                  ft891.c                \
                  ft897.c                \
                  ft900.c                \
                  ft920.c                \
                  ft950.c                \
                  ft980.c                \
                  ft990.c                \
                  ft991.c                \
                  ft1000d.c              \
                  ft1000mp.c             \
                  ft1200.c               \
                  ft2000.c               \
                  ft3000.c               \
                  ft5000.c               \
                  ft9000.c               \
                  ftdx10.c               \
                  ftdx101.c              \
                  ftdx101mp.c            \
                  newcat.c               \
                  vr5000.c               \
                  vx1700.c               \
                  yaesu.c)

#
# Code for Antenna Rotators:
#
hamlib_C_SRC += $(addprefix rotators/,  \
                  amsat/if100.c         \
                  ars/ars.c             \
                  celestron/celestron.c \
                  cnctrk/cnctrk.c       \
                  easycomm/easycomm.c   \
                  ether6/ether6.c       \
                  fodtrack/fodtrack.c   \
                  heathkit/hd1780.c     \
                  ioptron/rot_ioptron.c \
                  m2/rc2800.c           \
                  meade/meade.c         \
                  prosistel/prosistel.c \
                  rotorez/rotorez.c     \
                  sartek/sartek.c       \
                  satel/satel.c         \
                  spid/spid.c           \
                  ts7400/ts7400.c)

hamlib_C_SRC += $(addprefix rotators/gs232a/, \
                  gs232.c                     \
                  gs232a.c                    \
                  gs232b.c)

hamlib_C_SRC += $(addprefix amplifiers/elecraft/, \
                  kpa.c                           \
                  kpa1500.c)

#
# Untested.
#
ifeq ($(USE_LIBINDI),1)
  VPATH += $(LIBINDI_ROOT)/libs/indibase

  CFLAGS += -DHAVE_LIBINDI=1         \
            -DHAVE_INDIBASE_LAYOUT=1 \
            -I$(LIBINDI_ROOT)        \
            -I$(LIBINDI_ROOT)/libs   \
            -I$(LIBINDI_ROOT)/../zlib

  hamlib_C_SRC  += rotators/indi/indi.c
  hamlib_CPP_SRC = rotators/indi/indi_wrapper.cpp \
                   $(addprefix $(LIBINDI_ROOT)/libs/indibase/, \
                     basedevice.cpp                            \
                     indiproperty.cpp)
endif

ifeq ($(USE_GNURADIO),1)
  VPATH  += extra/gnuradio
  CFLAGS += -I./extra/gnuradio -I$(GNURADIO_ROOT)/include

  hamlib_C_SRC += $(addprefix extra/gnuradio/, \
                    gr.c                       \
                    graudio.c                  \
                    mc4020.c)

  hamlib_CC_SRC += gnuradio/gnuradio.cc
endif

#
# Various support code for Hamlib's internal use:
#
hamlib_misc_SRC = lib/termios.c  \
                  lib/win-misc.c \
                  tests/sprintflst.c

ifneq ($(CC),gcc)
  hamlib_misc_SRC += $(addprefix lib/, \
                       getopt_long.c   \
                       gettimeofday.c  \
                       usleep.c)
endif

#
# .cc sources for $(Hamlib++_DLL)':
#
hamlib++_SRC = $(addprefix c++/, \
                 ampclass.cc     \
                 rigclass.cc     \
                 rotclass.cc)

#
# .c sources for various programs:
#
ampctl_SRC = $(addprefix tests/, \
               ampctl.c          \
               ampctl_parse.c    \
               dumpcaps_amp.c)

ampctld_SRC = $(addprefix tests/, \
                ampctld.c         \
                ampctl_parse.c    \
                dumpcaps_amp.c)

rigctlcom_SRC = $(addprefix tests/, \
                  dumpcaps.c        \
                  rigctlcom.c       \
                  rigctl_parse.c)

rigctl_SRC = $(addprefix tests/, \
               dumpcaps.c        \
               dumpcaps_rot.c    \
               rigctl.c          \
               rigctl_parse.c)

rigctld_SRC = $(addprefix tests/, \
                dumpcaps.c        \
                dumpcaps_rot.c    \
                rigctld.c         \
                rigctl_parse.c)

rigmem_SRC = $(addprefix tests/, \
               rigmem.c          \
               memcsv.c          \
               memload.c         \
               memsave.c)

rotctl_SRC = $(addprefix tests/, \
               rotctl.c          \
               rotctl_parse.c    \
               dumpcaps.c        \
               dumpcaps_rot.c)

rotctld_SRC = $(addprefix tests/, \
                rotctld.c         \
                rotctl_parse.c    \
                dumpcaps.c        \
                dumpcaps_rot.c)

hamlib_C_OBJ    = $(call c_to_obj,  $(hamlib_C_SRC))
hamlib_CC_OBJ   = $(call cc_to_obj, $(hamlib_CC_SRC))
hamlib_CPP_OBJ  = $(call cpp_to_obj,$(hamlib_CPP_SRC))
hamlib++_OBJ    = $(call cc_to_obj, $(hamlib++_SRC))

hamlib_misc_OBJ = $(call c_to_obj, $(hamlib_misc_SRC))
ampctl_OBJ      = $(call c_to_obj, $(ampctl_SRC))
ampctld_OBJ     = $(call c_to_obj, $(ampctld_SRC))
rigctlcom_OBJ   = $(call c_to_obj, $(rigctlcom_SRC))
rigctl_OBJ      = $(call c_to_obj, $(rigctl_SRC))
rigctld_OBJ     = $(call c_to_obj, $(rigctld_SRC))
rigmatrix_OBJ   = $(call c_to_obj, tests/rigmatrix.c)
rigmem_OBJ      = $(call c_to_obj, $(rigmem_SRC))
rotctl_OBJ      = $(call c_to_obj, $(rotctl_SRC))
rotctld_OBJ     = $(call c_to_obj, $(rotctld_SRC))

hamlib_i   = $(call c_to_i,  $(hamlib_C_SRC))
hamlib++_i = $(call cc_to_i, $(hamlib++_SRC))

$(hamlib_C_OBJ)  \
$(hamlib++_OBJ)  \
$(hamlib_i)      \
$(hamlib++_i):   EXTRA_CFLAGS = -DIN_HAMLIB

$(hamlib++_OBJ)  \
$(hamlib++_i):   EXTRA_CFLAGS += -DDLL_EXPORT

all_test_OBJ = $(addprefix $(OBJ_DIR)/, \
                 dumpmem.$(O)           \
                 example.$(O)           \
                 listrigs.$(O)          \
                 rig_bench.$(O)         \
                 rigsmtr.$(O)           \
                 rigswr.$(O)            \
                 simyaesu.$(O)          \
                 testcpp.$(O)           \
                 testfreq.$(O)          \
                 testbcd.$(O)           \
                 testfreq.$(O)          \
                 testloc.$(O)           \
                 testrig.$(O)           \
                 testrigcaps.$(O)       \
                 testrigopen.$(O)       \
                 testtrn.$(O))

all_test_OBJ += $(ampctl_OBJ)    \
                $(ampctld_OBJ)   \
                $(rigctlcom_OBJ) \
                $(rigctl_OBJ)    \
                $(rigctld_OBJ)   \
                $(rigmatrix_OBJ) \
                $(rigmem_OBJ)    \
                $(rotctl_OBJ)    \
                $(rotctld_OBJ)   \

all_test_I = $(notdir $(all_test_OBJ:.$(O)=.i))

$(all_test_OBJ) $(all_test_I): EXTRA_CFLAGS = $(PROG_CFLAGS)

.SECONDARY: $(all_test_OBJ)

GENERATED = config.h \
            tests/hamlibdatetime.h

ifneq ($(CC),gcc)
  GENERATED += $(addprefix $(OBJ_DIR)/, \
                 unistd.h               \
                 termios.h              \
                 strings.h              \
                 sys/time.h             \
                 sys/ioctl.h)
endif

all: $(OBJ_DIR) $(OBJ_DIR)/sys $(GENERATED) rm_elecraft $(TARGETS) programs epilogue

$(OBJ_DIR) $(OBJ_DIR)/sys:
	- $(MKDIR) $@

#
# This is a 0-byte file that messes with 'rigs/kenwood/elecraft.c'
#
rm_elecraft:
	rm -f amplifiers/elecraft/elecraft.c

epilogue:
	$(call white_message, Welcome to $(Hamlib_DLL) and $(Hamlib++_DLL) (CPU=$(CPU)).)
	$(call green_message, You could also do a 'make -f $(THIS_FILE) [doxy_docs | py_module | lua_module]'.\n)

programs: $(GENERATED) $(TESTS_PROGS)

$(hamlib_misc_OBJ): EXTRA_CFLAGS += -DIN_HAMLIB_MISC_LIB

$(misc_LIB): $(hamlib_misc_OBJ)
	$(call create_lib, $@, $^)

$(Hamlib_STAT_LIB): $(hamlib_C_OBJ) $(hamlib_CC_OBJ) $(hamlib_CPP_OBJ)
	$(call create_lib, $@, $^)

$(Hamlib_IMP_LIB):   $(Hamlib_DLL)
$(Hamlib++_IMP_LIB): $(Hamlib++_DLL)

$(Hamlib_DLL): $(OBJ_DIR)/Hamlib.def $(Hamlib_STAT_LIB) $(misc_LIB) $(OBJ_DIR)/Hamlib.res
	$(call link_DLL, $@, $(Hamlib_IMP_LIB), $(call select,,-def:)$^ $(EX_LIBS))

$(Hamlib++_DLL): $(hamlib++_OBJ) $(Hamlib_IMP_LIB) $(OBJ_DIR)/Hamlib++.res
	$(call link_DLL, $@, $(Hamlib++_IMP_LIB), $^ $(call select, -lstdc++,) $(EX_LIBS))

#
# For MSVC only.
#
ifeq ($(USE_MP_COMPILE),1)
  $(hamlib_C_OBJ): $(hamlib_C_SRC) | $(CC).args
	$(CC) -MP @$(CC).args -DIN_HAMLIB -Fo./$(OBJ_DIR)\\ $(hamlib_C_SRC)
	@echo
endif

$(CC).args: $(THIS_FILE)
	$(call green_message, Creating $@)
	$(call create_resp_file, $@, $(CFLAGS) -c)

#
# For 'testcpp.exe':
#
testcpp.exe: $(OBJ_DIR)/testcpp.$(O) $(CPP_PROG_LIBS)
	$(call link_EXE, $@, $^ $(call select, -lstdc++,) $(EX_LIBS))

#
# For '$(TESTS_PROGS)':
#
$(OBJ_DIR)/%.$(O): tests/%.c | $(CC).args
	$(call Compile, $<, $@)

ampctl.exe: $(ampctl_OBJ) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

ampctld.exe: $(ampctld_OBJ) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

rigctlcom.exe: $(rigctlcom_OBJ) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

rigctl.exe: $(rigctl_OBJ) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

rigctld.exe: $(rigctld_OBJ) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

rigmem.exe: $(rigmem_OBJ) $(C_PROG_LIBS) $(XML2_LIB)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

rotctl.exe: $(rotctl_OBJ) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

rotctld.exe: $(rotctld_OBJ) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

#
# I do not have a GD.lib for MSVC/clang. Use the dynamic MinGW version instead.
# Copy it's .DLL here to avoid another DLL-hell.
#
rigmatrix.exe: $(rigmatrix_OBJ) $(C_PROG_LIBS) $(LIBGD_ROOT)/src/libgd.dll.a
	$(call link_EXE, $@, $^ $(PROG_LIBS))
	$(COPY) $(LIBGD_ROOT)/src/bgd.dll .

#
# For all other simple test-programs:
#
%.exe: $(OBJ_DIR)/%.$(O) $(C_PROG_LIBS)
	$(call link_EXE, $@, $^ $(PROG_LIBS))

#
# For '$(hamlib_C_SRC)' and '$(hamlib_CC_SRC)':
#
$(OBJ_DIR)/%.$(O): %.c | $(CC).args
	$(call Compile, $<, $@)

$(OBJ_DIR)/%.$(O): %.cc | $(CC).args
	$(call Compile, $<, $@)

$(OBJ_DIR)/%.$(O): %.cpp | $(CC).args
	$(call Compile, $<, $@)

#
# For '$(hamlib_misc_SRC)' since 'lib' is not in 'VPATH' due to 'lib/dummy.c'.
#
$(OBJ_DIR)/%.$(O): lib/%.c | $(CC).args
	$(call Compile, $<, $@)

clean: $(CC)_clean
	rm -f $(GENERATED) $(OBJ_DIR)/*.{$(O),rc,res,def} \
	      $(TESTS_PROGS:.exe=.map) cl.args clang-cl.args gcc.args lib.args cpp_filter.py
	- $(RMDIR) $(OBJ_DIR)/sys $(OBJ_DIR)

gcc_clean: ;

cl_clean clang-cl_clean:
	rm -f link.tmp vc1*.pdb $(Hamlib_DLL:.dll=.pdb) $(Hamlib++_DLL:.dll=.pdb) \
	      $(TESTS_PROGS:.exe=.pdb) $(TESTS_PROGS:.exe=.exp) $(TESTS_PROGS:.exe=.lib)

vclean realclean: clean doc_clean py_clean lua_clean
	rm -f $(TARGETS) $(Hamlib_DLL:.dll=.map) $(Hamlib++_DLL:.dll=.map) \
	      $(TESTS_PROGS) bgd.dll .depend.Windows

config.h: $(THIS_FILE)
	$(call Generate, $@, //)
	$(file >> $@,#ifndef _CONFIG_H)
	$(file >> $@,#define _CONFIG_H)
	$(file >> $@,$(CONFIG_H))
	$(file >> $@,#endif /* _CONFIG_H */)

tests/hamlibdatetime.h: $(THIS_FILE)
	$(call Generate, $@, //)
	$(file >> $@, #define HAMLIBDATETIME "__DATE__")

$(OBJ_DIR)/unistd.h: $(THIS_FILE)
	$(call Generate_fake, $@, #include "lib/getopt.h")

$(OBJ_DIR)/sys/time.h: $(THIS_FILE)
	$(call Generate_fake, $@)

$(OBJ_DIR)/strings.h: $(THIS_FILE)
	$(call Generate_fake, $@, #include <string.h>)

$(OBJ_DIR)/termios.h: $(THIS_FILE)
	$(call Generate_fake, $@)

$(OBJ_DIR)/sys/ioctl.h: $(THIS_FILE)
	$(call Generate_fake, $@)

%.i: %.c FORCE $(GENERATED) cpp_filter.py $(CC).args
	$(call Cxx_preprocess, $@, $<, c)

%.i: lib/%.c FORCE $(GENERATED) cpp_filter.py $(CC).args
	$(call Cxx_preprocess, $@, $<, c)

%.i: $(OBJ_DIR)/%.c FORCE $(GENERATED) cpp_filter.py $(CC).args
	$(call Cxx_preprocess, $@, $<, c)

%.i: %.cc FORCE $(GENERATED) cpp_filter.py $(CC).args
	$(call Cxx_preprocess, $@, $<, cpp)

%.i: %.cpp FORCE $(GENERATED) cpp_filter.py $(CC).args
	$(call Cxx_preprocess, $@, $<, cpp)

FORCE:

#
# Create API documentation in 'doc/html/index.html':
#
doxy_docs: doc/Hamlib.cfg
	cd doc                            ; \
	doxygen Hamlib.cfg 2> doxygen.log ; \
	cd html                           ; \
	hhc index.hhp                     ; \
	mv -f Hamlib.chm ..
	@echo 'Doxygen done. Look in "doc/doxygen.log" for messages.'

doc/Hamlib.cfg: $(THIS_FILE)
	$(call Generate, $@, #)
	$(file >> $@,$(hamlib_CFG))

doc_clean:
	rm -f doc/doxygen.log doc/hamlib.cfg doc/Hamlib.chm
	rm -fR doc/html/*
	- rmdir doc/html

#
# Python 2/3 module stuff.
#
# Get the Python prefix via the 'py -x' launcher.
# The Python major version (2 or 3) is simply '$(USE_PY_BINDING)'.
#
PY_ROOT = $(subst \,/,$(shell py -$(USE_PY_BINDING) -c "import sys; print(sys.prefix)"))

ifeq ($(USE_PY_BINDING),2)
  PY_WRAPPER_C = $(OBJ_DIR)/HamlibPy2_wrap.c
  PY_WRAPPER_O = $(OBJ_DIR)/HamlibPy2_wrap.$(O)

else ifeq ($(USE_PY_BINDING),3)
  PY_WRAPPER_C = $(OBJ_DIR)/HamlibPy3_wrap.c
  PY_WRAPPER_O = $(OBJ_DIR)/HamlibPy3_wrap.$(O)
endif

ifeq ($(CC),gcc)
  PYD_LIBS = $(PY_ROOT)/libs/libpython$(USE_PY_BINDING)*.a
endif

_Hamlib_PYD_deps = $(PY_WRAPPER_O) $(OBJ_DIR)/HamlibPy.res $(Hamlib_IMP_LIB)
PY_CFLAGS        = -I$(PY_ROOT)/include -DNO_SSIZE_T -DDLL_EXPORT

ifeq ($(USE_PY_BINDING),0)
  py_module:
	$(error Use 'USE_PY_BINDING=[2|3]'.)

else
  py_module: _Hamlib.pyd $(OBJ_DIR)/Hamlib.py $(Hamlib_DLL)
	$(COPY) $^ $(PY_ROOT)/Lib/site-packages
ifneq ($(CC),gcc)
	$(COPY) _Hamlib.pdb $(PY_ROOT)/Lib/site-packages
endif
endif

$(OBJ_DIR)/Hamlib.py: $(PY_WRAPPER_C)

SWIG_FLAGS = -I./include -I./bindings # -macroerrors

$(PY_WRAPPER_C): bindings/Hamlib.swg include/hamlib/rig.h
	$(call green_message, Generating $@ and $(OBJ_DIR)/Hamlib.py)
	swig -python $(SWIG_FLAGS) -o $@ $<

$(PY_WRAPPER_O) $(PY_WRAPPER_C:.c=.i): EXTRA_CFLAGS += $(PY_CFLAGS)

ifeq ($(USE_PY_BINDING),3)
   _Hamlib.pyd: $(_Hamlib_PYD_deps)
		$(call link_PYD, $@, $^ $(PYD_LIBS), PyInit__Hamlib)

else ifeq ($(USE_PY_BINDING),2)
  _Hamlib.pyd: $(_Hamlib_PYD_deps)
		$(call link_PYD, $@, $^ $(PYD_LIBS), init_Hamlib)
endif

py_JUNK = $(OBJ_DIR)/Hamlib.py \
          _Hamlib.pyd          \
          _Hamlib.map          \
          _Hamlib.pdb          \
          _Hamlib.exp          \
          _Hamlib.lib          \
          $(PY_WRAPPER_C)      \
          $(OBJ_DIR)/HamlibPy.res

py_clean:
	rm -f $(py_JUNK)

#
# Lua module stuff. Only LuaJIT seems to be stable.
#
# The 'HamlibLua.dll' exports only 'luaopen_Hamliblua()'
#
lua_module: HamlibLua.dll
	$(call green_message, Remember to update your 'LUA_CPATH' for 'HamlibLua.dll'. And your 'PATH' for the needed '$(Hamlib_DLL)')
#	$(COPY) $^ $(some_where_on_PATH_and_LUA_CPATH)

$(OBJ_DIR)/HamlibLua_wrap.c: bindings/Hamlib.swg
	$(call green_message, Generating $@)
	swig -lua $(SWIG_FLAGS) -o $@ $<

$(OBJ_DIR)/HamlibLua_wrap.$(O) HamlibLua_wrap.i: EXTRA_CFLAGS = -I$(LUA_ROOT)/src -DDLL_EXPORT

#
# The imp-lib 'HamlibLua.$(A)' is not needed for anything.
#
HamlibLua.dll: $(OBJ_DIR)/HamlibLua_wrap.$(O) $(Hamlib_IMP_LIB) $(OBJ_DIR)/HamlibLua.res
	$(call link_DLL, $@, HamlibLua.$(A), $^ $(LUA_LIB))

lua_JUNK = HamlibLua.dll  \
           HamlibLua.$(A) \
           HamlibLua.map  \
           HamlibLua.pdb  \
           HamlibLua.exp  \
           $(OBJ_DIR)/HamlibLua_wrap.c

lua_clean:
	rm -f $(lua_JUNK)

$(OBJ_DIR)/Hamlib.rc: $(THIS_FILE)
	$(call make_rc, $@, $(Hamlib_DLL), "Ham Radio Control Library for C", VFT_DLL)

$(OBJ_DIR)/Hamlib++.rc: $(THIS_FILE)
	$(call make_rc, $@, $(Hamlib++_DLL), "Ham Radio Control Library for C++", VFT_DLL)

$(OBJ_DIR)/HamlibPy.rc: $(THIS_FILE)
	$(call make_rc, $@, _Hamlib.pyd, "Hamlib module for Python v$(USE_PY_BINDING).x", VFT_DLL)

$(OBJ_DIR)/HamlibLua.rc: $(THIS_FILE)
	$(call make_rc, $@, HamlibLua.dll, "Hamlib module for LuaJIT", VFT_DLL)

$(OBJ_DIR)/%.res: $(OBJ_DIR)/%.rc config.h
	$(call make_res, $<, $@)

#
# Create an export definition file by using 'nm $(Hamlib_STAT_LIB)' to
# extract all the public functions;
# i.e. ' T ' symbols are "Text symbol, global". See 'man nm' for details.
#
# On 'CPU=x86', all symbols have a leading '_'. Drop these.
#
# Ignore symbols matching ' Wspiapi.*' and ' _.*'.
#
# Append the DATA symbols manually.
#
ifeq ($(CPU),x86)
  uscore := _
endif

#
# Export all code symbols.
#
extract_code_syms = nm $(2) | grep ' T $(uscore)[a-zA-Z0-9_]*' | \
                    sed -e 's@^.* $(uscore)@  @g'                \
                        -e 's@ Wspiapi.*@@g'                     \
                        -e 's@ _.*@@g' | sort | uniq >> $(1)

define Hamlib_DATA
  hamlib_version    DATA
  hamlib_copyright  DATA
  hamlib_version2   DATA
  hamlib_copyright2 DATA
  debugmsgsave      DATA
  debugmsgsave2     DATA
endef

export Hamlib_DATA

#
# We export stuff using this generated .def-file:
#
$(OBJ_DIR)/Hamlib.def: $(Hamlib_STAT_LIB) $(THIS_FILE)
	$(call Generate, $@, ;)
	$(file >> $@, LIBRARY $(Hamlib_DLL))
	$(file >> $@, EXPORTS)
	$(call extract_code_syms, $@, $<)
	@echo "$$Hamlib_DATA" >> $@

#
# GNU-make macros.
#
# This assumes you have a Cygwin/Msys 'echo' with colour support.
#
green_message = @echo -e "\e[1;32m$(strip $(1))\e[0m"
white_message = @echo -e "\e[1;37m$(strip $(1))\e[0m"

#
# .c compile macro.
#   $(1): the .c file (and extra CFLAGS)
#   $(2): the .$(O) file
#
# Do not use '@gcc.args' since some old gcc gets confused by it!?
#
ifeq ($(CC),gcc)
  define Compile
    $(CC) @$(CC).args $(EXTRA_CFLAGS) -o $(2) $(1)
    @echo
  endef
else
  define Compile
    $(CC) @$(CC).args $(EXTRA_CFLAGS) -Fo$(strip $(2)) $(1)
    @echo
  endef
endif

#
# Create an EXE from objects.
#   arg1, $(1): The .exe file.
#   arg2, $(2): The .$(O) file(s), extra args and libs.
#
define link_EXE
  $(call green_message, Linking $(1))
  $(call link_EXE_$(CC), $(1), $(2))
  @echo
endef

define link_EXE_cl
  link $(LDFLAGS) -out:$(strip $(1)) $(2) > link.tmp
  @cat link.tmp >> $(1:.exe=.map)
endef

link_EXE_clang-cl = $(call link_EXE_cl, $(1), $(2))
link_EXE_gcc      = $(CC) $(LDFLAGS) -o $(1) $(2) > $(1:.exe=.map)

#
# Macro to create a DLL + import-lib from objects.
#   arg1, $(1): The .dll file.
#   arg2, $(2): The import-lib.
#   arg3, $(3): The .$(O) file(s), extra args and libs.
#
define link_DLL
  $(call green_message, Linking $(1))
  $(call link_DLL_$(CC), $(1), $(2), $(3))
  @echo
endef

define link_DLL_cl
  link -dll $(LDFLAGS) -out:$(strip $(1)) -implib:$(strip $(2)) $(3) > link.tmp
  @cat link.tmp >> $(1:.dll=.map)
  @rm -f $(2:.lib=.exp)
endef

link_DLL_clang-cl = $(call link_DLL_cl, $(1), $(2), $(3))
link_DLL_gcc      = $(CC) -shared $(LDFLAGS) -o $(1) -Wl,--out-implib,$(strip $(2)) $(3) > $(1:.dll=.map)

#
# Macro to create a Python .PYD-module from objects.
#   arg1, $(1): The .pyd file.
#   arg2, $(2): The .$(O) file(s), extra args and libs.
#   arg3, $(3): The name of the Python init function.
#         Not used by MinGW. It exports the 'SWIGEXPORT SWIG_init()' function
#         in the 'HamlibPyX_wrap.c' code.
#
define link_PYD
  $(call green_message, Linking $(1))
  $(call link_PYD_$(CC), $(1), $(2), $(3))
  @echo
endef

define link_PYD_cl
  link -dll $(LDFLAGS) -libpath:$(PY_ROOT)/libs -export:$(strip $(3)) -out:$(strip $(1)) $(2) > link.tmp
  @cat link.tmp >> $(1:.pyd=.map)
  @rm -f $(1:.pyd=.exp) $(1:.pyd=.lib)
endef

link_PYD_clang-cl = $(call link_PYD_cl, $(1), $(2), $(3))
link_PYD_gcc      = $(CC) -shared $(LDFLAGS) -o $(1) $(2) > $(1:.pyd=.map)

define make_res
  $(call green_message, Creating $(2))
  $(call make_res_$(CC), $(1), $(2))
  @echo
endef

make_res_cl       = rc -nologo -D_MSC_VER  -Fo./$(strip $(2)) $(1)
make_res_clang-cl = rc -nologo -D__clang__ -Fo./$(strip $(2)) $(1)
make_res_gcc      = windres -D__MINGW32__ -O COFF -I. $(RCFLAGS) -o $(2) -i $(1)

#
# static .lib creation macro:
#   arg1: $(1): the .$(A) file.
#   arg2: $(2): the .$(O) files to put in it.
#
define create_lib
  @rm -f $(1)
  $(call green_message, Creating $(1))
  $(call create_resp_file, lib.args, $(2))
  $(call create_lib_$(CC), $(1))
  @echo
endef

create_lib_cl       = lib -nologo -out:$(strip $(1)) @lib.args
create_lib_clang-cl = $(call create_lib_cl, $(1))
create_lib_gcc      = ar rs $(1) @lib.args

#
# Create a response file $(1).
# One word from $(2) per line.
#
define create_resp_file
  $(file > $(1))
  $(foreach f, $(2), $(file >> $(1),$(strip $(f))) )
endef

define Warning
 $(1)
 $(1) DO NOT EDIT! This file was automatically generated
 $(1) from $(realpath $(THIS_FILE)) at $(DATE).
 $(1) Edit that file instead.
 $(1)
endef

define Generate
  $(call green_message, Generating $(1))
  $(file > $(1),$(call Warning,$(strip $(2))))
endef

define Generate_fake
  $(call Generate, $(1), //)
  $(file >> $(1), // fake <$(strip $(1))> for MSVC/clang-cl)
  $(file >> $(1), $(2))
endef

define CONFIG_H
  #define ABI_VERSION   $(ABI_VER)

  #if defined(IN_HAMLIB) && defined(DLL_EXPORT) && !defined(__cplusplus)
  #error "Do not use '-DDLL_EXPORT' since we use a .def-file to control the exports."
  #endif

  #ifndef WIN32
  #define WIN32 1
  #endif

  #if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0601)
    #undef  _WIN32_WINNT
    #define _WIN32_WINNT  0x0601
  #endif

  #define WIN32_LEAN_AND_MEAN

  /*
   * MSVC/clang-cl:
   *   Except for .cc code (the 'LIBUSB_ROOT' code that needs Boost), and
   *   while doing 'make depend', pretend we are MinGW.
   */
  #if defined(_MSC_VER)
    #define _CRT_SECURE_NO_WARNINGS
    #define _CRT_NONSTDC_NO_WARNINGS

    struct timeval;    /* Forward */
    struct timezone;   /* Forward */

    extern int gettimeofday (struct timeval *, struct timezone *);
  #else
    /*
     * MinGW section:
     */
    #define HAVE_PTHREAD          1
    #define HAVE_UNISTD_H         1
    #define HAVE_SELECT           1
    #define HAVE_SSLEEP           1
    #define HAVE_SYS_TIME_H       1
    #define HAVE_STRTOK_R         1

    #include <sys/time.h>         /* 'gettimeofday()' */
  #endif

  #include <windows.h>
  #include <winsock2.h>           /* 'struct timeval' etc. */
  #include <ws2tcpip.h>           /* 'gai_strerror()' etc. */
  #include <time.h>               /* 'struct timespec' etc. */
  #include <io.h>                 /* 'open()', 'close()' etc. */
  #include <stdint.h>             /* 'int64_t' etc. */
  #include <process.h>            /* 'getpid()' etc. */
  #include <malloc.h>             /* 'alloca()' etc. */

  #define HAVE_SYS_TYPES_H        1
  #define HAVE_INTTYPES_H         1
  #define HAVE_WINRADIO           1
  #define HAVE_WINDOWS_H          1
  #define HAVE_WINBASE_H          1
  #define HAVE_WS2TCPIP_H         1
  #define HAVE_WSPIAPI_H          1
  #define HAVE_GETADDRINFO        1
  #define HAVE_DECL_GAI_STRERROR  1
  #define HAVE_SELECT             1
  #define HAVE_SSLEEP             1
  #define HAVE_SLEEP              1

  #if defined(_MSC_VER)
    #ifndef __clang__
    #define __attribute__(x)
    #endif

    #define strncasecmp(s1, s2, n)  _strnicmp (s1, s2, n)
    #define sleep(s)                Sleep (1000*(s))

    extern int usleep (unsigned long usec);
  #endif

  /* No point in defining this
   */
//#define HAVE_SIGNAL     1

  /* Since 'WIN32_LEAN_AND_MEAN' is defined, this header is
   * not included in <windows.h>. So do it explicitly, but it is
   * only needed in 'rigs/winradio/g313-win.c'.
   */
  #include <mmsystem.h>

  #define _TIMEVAL_DEFINED
  #define _TIMESPEC_DEFINED
  #define  _USE_MATH_DEFINES  /* 'M_PI' etc. */

  #if !defined(_SSIZE_T_DEFINED) && !defined(NO_SSIZE_T)
    #include <basetsd.h>

    typedef SSIZE_T ssize_t;
    #define _SSIZE_T_DEFINED
  #endif

  #if !defined(_UINT_DEFINED)
    typedef unsigned int uint;

    #define _UINT_DEFINED
  #endif

  #if !defined(_MODE_T_DEFINED) && !defined(__MINGW32__)
    typedef unsigned short mode_t;
    #define _MODE_T_DEFINED
  #endif

  #if !defined(timersub)
    #define timersub(a, b, result) do {                      \
            (result)->tv_sec  = (a)->tv_sec - (b)->tv_sec;   \
            (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
            if ((result)->tv_usec < 0) {                     \
               --(result)->tv_sec;                           \
               (result)->tv_usec += 1000000;                 \
            }                                                \
          } while (0)
  #endif

  /* Hack for using libusrp dynamically (untested)
   */
  #ifdef HAVE_USRP
  #define LIBUSRP_SPEC        __declspec(dllimport)
  #endif

  #define PACKAGE_VERSION    "$(VERSION)"

  /* Functions in 'lib/win-misc.c':
   */
  #ifndef CLOCK_REALTIME
  #define CLOCK_REALTIME  0
  #endif

  extern int clock_gettime (int clock_id, struct timespec *ts);

  #ifndef HAVE_STRTOK_R
    extern char *strtok_r (char *s, const char *delim, char **ptrptr);
  #endif

endef

#
# The contents of 'doc/Hamlib.cfg' used by Doxygen.
#
define hamlib_CFG
  #
  # All paths are relative to './doc'.
  #
  PROJECT_NAME     = "Hamlib"
  PROJECT_NUMBER   = $(VERSION)
  PROJECT_LOGO     = hamlib.png
  OUTPUT_DIRECTORY = .
  PREDEFINED       = __GNUC__ DOXYGEN DOC_HIDDEN
  OUTPUT_LANGUAGE  = English
  GENERATE_HTML    = YES
  GENERATE_LATEX   = NO
  GENERATE_RTF     = NO
  GENERATE_MAN     = NO
  MAN_EXTENSION    = .3
  TAB_SIZE         = 4
  CASE_SENSE_NAMES = NO
  FULL_PATH_NAMES  = NO
# ALIASES          = \RETURNFUNC{1}="\b RETURNFUNC(\1)" \

  INPUT            = index.doxygen ../src/ ../include/hamlib/
  INCLUDE_PATH     = ../include/
  EXAMPLE_PATH     = ..                              \
                     ../tests/testrig.c              \
                     ../scripts/README.build-Windows \
                     ../scripts/build-w32.sh         \
                     ../scripts/build-w64.sh

  EXCLUDE          = ../src/amp_conf.h            \
                     ../include/hamlib/ampclass.h \
                     ../include/hamlib/rotclass.h

  QUIET                 = YES
  HTML_EXTRA_STYLESHEET = hamlib.css
  HTML_FOOTER           = footer.html

  EXTRACT_ALL           = NO
  EXTRACT_STATIC        = NO
  HIDE_UNDOC_MEMBERS    = NO
  SHOW_INCLUDE_FILES    = YES
  INHERIT_DOCS          = YES
  ENABLED_SECTIONS      = ""
  JAVADOC_AUTOBRIEF     = NO
  OPTIMIZE_OUTPUT_FOR_C = YES
  MAN_LINKS             = NO
  MACRO_EXPANSION       = YES
  SOURCE_BROWSER        = YES
  STRIP_CODE_COMMENTS   = NO
  GENERATE_HTMLHELP     = YES
  CHM_FILE              = Hamlib.chm
  SEARCHENGINE          = NO
endef

define RC_COMMON
  #include <winver.h>

  #if defined(__clang__)
    #define RC_BUILDER  "clang-cl"

  #elif defined(_MSC_VER)
    #define RC_BUILDER  "MSVC"

  #elif defined(__MINGW32__)
    #define RC_BUILDER  "MinGW"

  #else
    #error "Who are you?"
  #endif

  #ifndef RC_DESCRIPTION
  #error "Add a #define RC_DESCRIPTION .."
  #endif

  #ifndef RC_FILENAME
  #error "Add a #define RC_FILENAME .."
  #endif

  #ifndef RC_FILETYPE
  #define RC_FILETYPE VFT_DLL
  #endif

  #define RC_VERSION      $(MAJOR_VER),$(MINOR_VER),0,0
  #define RC_VER_STRING  "$(VERSION).0.0 (" RC_BUILDER ", $(CPU))"

  VS_VERSION_INFO VERSIONINFO
    FILEVERSION     RC_VERSION
    PRODUCTVERSION  RC_VERSION
    FILEFLAGSMASK   0x3fL
    FILEOS          VOS__WINDOWS32
    FILETYPE        RC_FILETYPE
    FILEFLAGS       0x0L
    FILESUBTYPE     0x0L

  BEGIN
    BLOCK "StringFileInfo"
    BEGIN
      BLOCK "040904b0"
      BEGIN
        VALUE "CompanyName",      "https://hamlib.github.io/"
        VALUE "FileDescription",  RC_DESCRIPTION
        VALUE "FileVersion",      RC_VER_STRING
        VALUE "InternalName",     "Hamlib, ABI ver. $(ABI_VER)"
        VALUE "LegalCopyright",   "GNU General Public License v2.0"
        VALUE "OriginalFilename", RC_FILENAME
        VALUE "ProductName",      RC_FILENAME
        VALUE "ProductVersion",   RC_VER_STRING
        VALUE "PrivateBuild",     "The privat build of <gvanem@yahoo.no>."
        VALUE "SpecialBuild",     ""
        VALUE "Comments",         "Built on $(DATE)"
      END
    END
  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x409, 1200
  END
  END
endef

define make_rc
  $(call Generate, $(1), //)
  $(file >> $@, #define RC_FILENAME    "$(strip $(2))")
  $(file >> $@, #define RC_DESCRIPTION  $(3))
  $(file >> $@, #define RC_FILETYPE     $(4))
  $(file >> $@, $(RC_COMMON))
endef

ifeq ($(USE_ASTYLE),1)
  define Cxx_preprocess
    $(file  > $(1),/* The preprocessed and AStyle formatter output of '$(strip $(2))':)
    $(file >> $(1), * $(CC) -E)
    @$(foreach f, $(CFLAGS) $(EXTRA_CFLAGS), $(file >> $(1), * $(f)))
    $(file >> $(1), *---------------------------------------------------------)
    $(file >> $(1), */)
    $(CC) -E @$(CC).args $(EXTRA_CFLAGS) $(2) | $(PYTHON) cpp_filter.py | astyle >> $(1)
  endef

else ifeq ($(USE_CLANG_FORMAT),1)
  define Cxx_preprocess
    $(file  > $(1),/* The preprocessed and clang-formatted output of '$(strip $(2))':)
    $(file >> $(1), * $(CC) -E)
    @$(foreach f, $(CFLAGS) $(EXTRA_CFLAGS), $(file >> $(1), * $(f)))
    $(file >> $(1), *---------------------------------------------------------)
    $(file >> $(1), */)
    $(CC) -E @$(CC).args $(EXTRA_CFLAGS) $(2) | $(PYTHON) cpp_filter.py | clang-format --assume-filename=$(strip $(3)) >> $(1)
  endef

else
  define Cxx_preprocess
    $(file  > $(1),/* The raw preprocessed output of '$(strip $(2))':)
    $(file >> $(1), * $(CC) -E)
    @$(foreach f, $(CFLAGS) $(EXTRA_CFLAGS), $(file >> $(1), * $(f)))
    $(file >> $(1), *---------------------------------------------------------)
    $(file >> $(1), */)
    $(CC) -E @$(CC).args $(EXTRA_CFLAGS) $(2) | $(PYTHON) cpp_filter.py >> $(1)
  endef
endif

define CPP_FILTER_PY
  import sys, os

  try:
    import ntpath
  except ImportError as e:
    print ("Failed to import ntpath: %s" % e)
    sys.exit(1)

  def _win32_abspath (path):
    path = ntpath.abspath (path)
    return path.replace ('\\', '/')

  def skip_cwd (s1, s2):
    ''' Skip the leading part that is in common with s1 and s2
    '''
    i = 0
    while i < len(s1) and s1[i] == s2[i]:
       i += 1
    return s2[i:]

  cwd = _win32_abspath (os.getcwd()) + '/'

  last_line  = '??'
  last_fname = '??'
  empty_lines = 0

  while True:
    line = sys.stdin.readline()
    if not line:
      break
    if line.startswith('\n') or line.startswith('\r'):
      empty_lines += 1
      continue

    line = line.replace ("\\\\", "/")
    fname = None
    quote = line.find ('\"')

    if line.startswith ("#line ") and quote > 0:
      fname = _win32_abspath (line[quote:])
      last_fname = fname

    if line.strip() != '' and last_line != '':
      if fname is None or fname != last_fname:
        print (line, end="")

        if line.strip() == '}':  # Print a newline after a function
          print ("")

    last_line = line

  if empty_lines > 0:
    sys.stderr.write ("Removed %d empty lines.\n" % empty_lines)

endef

cpp_filter.py: $(THIS_FILE)
	$(call Generate, $@, #)
	$(file >> $@,from __future__ import print_function)
	$(file >> $@,if 1:)
	$(file >> $@,$(CPP_FILTER_PY))

#
# Use gcc to create a '.depend.Windows'
#
DEP_CFLAGS  = -MM --include config.h $(filter -I% -D%, $(CFLAGS))
DEP_REPLACE = sed -e 's@\(.*\)\.o: @\n$$(OBJ_DIR)\/\1.$$(O): @' \
                  -e 's@$(OBJ_DIR)/[a-z]*\.h@@g'                \
                  -e 's@$(OBJ_DIR)/sys/[a-z]*\.h@@g'            \
                  -e 's@$(LIBUSRP_ROOT)@$$(LIBUSRP_ROOT)@'

ALL_C_SRC  = $(hamlib_C_SRC)  $(hamlib_misc_SRC) $(wildcard tests/*.c)
ALL_CC_SRC = $(hamlib_CC_SRC) $(hamlib++_SRC) $(hamlib_CPP_SRC)

depend: $(OBJ_DIR) $(OBJ_DIR)/sys $(GENERATED)
	$(call Generate, .depend.Windows, #)
	$(call create_resp_file, depend1.args, $(DEP_CFLAGS) $(ALL_C_SRC))
	$(call create_resp_file, depend2.args, $(DEP_CFLAGS) -std=c++11 $(ALL_CC_SRC))
	gcc @depend1.args | $(DEP_REPLACE) >> .depend.Windows
	gcc @depend2.args | $(DEP_REPLACE) >> .depend.Windows
	rm -f depend1.args depend2.args

-include .depend.Windows

     2021 GitHub, Inc.
    Terms
    Privacy
    Security
    Status
    Docs

    Contact GitHub
    Pricing
    API
    Training
    Blog
    About

